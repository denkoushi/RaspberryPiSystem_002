name: CI

on:
  push:
    branches: [main, develop, 'feature/**', 'feat/**', 'fix/**', 'refactor/**', 'chore/**']
  pull_request:
    branches: [main, develop]
  workflow_dispatch:

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Validate deployment scripts
        run: |
          bash -n scripts/update-all-clients.sh
          bash -n scripts/server/deploy.sh
          bash -n scripts/server/deploy-detached.sh
          bash scripts/update-all-clients.sh main infrastructure/ansible/inventory.yml --print-plan

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Security scan (pnpm audit, high+)
        run: |
          # Temporarily skip security scan due to npm registry 500 errors
          # TODO: Re-enable when npm registry is stable
          echo "Skipping security scan due to npm registry issues"
          # pnpm audit --audit-level=high || {
          #   echo "Security scan failed!"
          #   exit 1
          # }

      - name: Run lint
        run: |
          pnpm lint --max-warnings=0 || {
            echo "Lint failed!"
            exit 1
          }

      - name: Build shared-types
        run: |
          cd packages/shared-types
          pnpm build

      - name: Generate Prisma Client
        run: |
          cd apps/api
          echo "Generating Prisma Client..."
          pnpm prisma generate || {
            echo "Prisma generate failed!"
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return

      - name: Build API
        run: |
          cd apps/api
          echo "Building API..."
          pnpm build || {
            echo "Build failed!"
            exit 1
          }

      - name: Start PostgreSQL
        run: |
          docker run -d \
            --name postgres-test \
            -e POSTGRES_PASSWORD=postgres \
            -e POSTGRES_DB=borrow_return \
            -p 5432:5432 \
            --health-cmd="pg_isready -U postgres" \
            --health-interval=10s \
            --health-timeout=5s \
            --health-retries=5 \
            postgres:15-alpine

      - name: Wait for PostgreSQL
        run: |
          timeout=60
          elapsed=0
          until docker exec postgres-test pg_isready -U postgres 2>/dev/null; do
            if [ $elapsed -ge $timeout ]; then
              echo "PostgreSQL failed to start within $timeout seconds"
              docker logs postgres-test
              exit 1
            fi
            echo "Waiting for PostgreSQL... ($elapsed/$timeout seconds)"
            sleep 2
            elapsed=$((elapsed + 2))
          done
          echo "PostgreSQL is ready!"
          # データベース接続の最終確認
          docker exec postgres-test psql -U postgres -d borrow_return -c "SELECT version();" || {
            echo "PostgreSQL connection test failed!"
            exit 1
          }

      - name: Run Prisma migrations
        run: |
          cd apps/api
          echo "Running Prisma migrations..."
          pnpm prisma migrate deploy || {
            echo "Migration failed, checking database connection..."
            docker exec postgres-test psql -U postgres -c "SELECT version();"
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return

      - name: Run API tests
        run: |
          cd apps/api
          echo "Running API tests..."
          echo "DATABASE_URL: $DATABASE_URL"
          echo "PostgreSQL connection test..."
          docker exec postgres-test psql -U postgres -d borrow_return -c "SELECT 1;" || {
            echo "PostgreSQL connection failed!"
            exit 1
          }
          # imports-scheduleは専用ステップで実行するため除外
          BACKUP_CONFIG_PATH=/tmp/test-backup.json PROJECT_ROOT=$(pwd) pnpm test:coverage -- --reporter=verbose --exclude "**/imports-schedule.integration.test.ts" || {
            echo "Tests failed, showing test output..."
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return
          JWT_ACCESS_SECRET: test-access-secret-1234567890
          JWT_REFRESH_SECRET: test-refresh-secret-1234567890
          CAMERA_TYPE: mock
          PHOTO_STORAGE_DIR: /tmp/test-photo-storage
          BACKUP_STORAGE_DIR: /tmp/test-backups
          NODE_ENV: test

      - name: Upload API coverage artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: api-coverage
          path: apps/api/coverage/
          retention-days: 7

      - name: Run API performance tests
        run: |
          cd apps/api
          echo "Running API performance tests..."
          BACKUP_CONFIG_PATH=/tmp/test-backup.json PROJECT_ROOT=$(pwd) pnpm test -- performance --reporter=verbose || {
            echo "Performance tests failed, showing test output..."
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return
          JWT_ACCESS_SECRET: test-access-secret-1234567890
          JWT_REFRESH_SECRET: test-refresh-secret-1234567890
          CAMERA_TYPE: mock
          PHOTO_STORAGE_DIR: /tmp/test-photo-storage
          BACKUP_STORAGE_DIR: /tmp/test-backups
          NODE_ENV: test
          PERF_RESPONSE_TIME_THRESHOLD_MS: 1800

      - name: Run backup service tests
        run: |
          cd apps/api
          echo "Running backup service tests..."
          BACKUP_CONFIG_PATH=/tmp/test-backup.json PROJECT_ROOT=$(pwd) pnpm test -- backup --reporter=verbose || {
            echo "Backup tests failed, showing test output..."
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return
          BACKUP_STORAGE_DIR: /tmp/test-backups
          NODE_ENV: test

      - name: Run imports-dropbox tests
        run: |
          cd apps/api
          echo "Running imports-dropbox tests..."
          pnpm test -- imports-dropbox --reporter=verbose || {
            echo "Imports-dropbox tests failed, showing test output..."
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return
          JWT_ACCESS_SECRET: test-access-secret-1234567890
          JWT_REFRESH_SECRET: test-refresh-secret-1234567890
          CAMERA_TYPE: mock
          PHOTO_STORAGE_DIR: /tmp/test-photo-storage
          BACKUP_STORAGE_DIR: /tmp/test-backups
          NODE_ENV: test

      - name: Run imports-gmail tests
        run: |
          cd apps/api
          echo "Running imports-gmail tests..."
          pnpm test -- imports-gmail --reporter=verbose || {
            echo "Imports-gmail tests failed, showing test output..."
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return
          JWT_ACCESS_SECRET: test-access-secret-1234567890
          JWT_REFRESH_SECRET: test-refresh-secret-1234567890
          CAMERA_TYPE: mock
          PHOTO_STORAGE_DIR: /tmp/test-photo-storage
          BACKUP_STORAGE_DIR: /tmp/test-backups
          NODE_ENV: test

      - name: Run csv-import-scheduler tests
        run: |
          cd apps/api
          echo "Running csv-import-scheduler tests..."
          BACKUP_CONFIG_PATH=/tmp/test-backup.json PROJECT_ROOT=$(pwd) pnpm test -- csv-import-scheduler --reporter=verbose || {
            echo "Csv-import-scheduler tests failed, showing test output..."
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return
          JWT_ACCESS_SECRET: test-access-secret-1234567890
          JWT_REFRESH_SECRET: test-refresh-secret-1234567890
          CAMERA_TYPE: mock
          PHOTO_STORAGE_DIR: /tmp/test-photo-storage
          BACKUP_STORAGE_DIR: /tmp/test-backups
          NODE_ENV: test

      - name: Run imports-schedule integration tests
        run: |
          cd apps/api
          echo "Running imports-schedule integration tests..."
          BACKUP_CONFIG_PATH=/tmp/test-backup.json PROJECT_ROOT=$(pwd) pnpm test -- imports-schedule --reporter=verbose || {
            echo "Imports-schedule integration tests failed, showing test output..."
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return
          JWT_ACCESS_SECRET: test-access-secret-1234567890
          JWT_REFRESH_SECRET: test-refresh-secret-1234567890
          CAMERA_TYPE: mock
          PHOTO_STORAGE_DIR: /tmp/test-photo-storage
          BACKUP_STORAGE_DIR: /tmp/test-backups
          NODE_ENV: test

      - name: Run import-alert service tests
        run: |
          cd apps/api
          echo "Running import-alert service tests..."
          BACKUP_CONFIG_PATH=/tmp/test-backup.json PROJECT_ROOT=$(pwd) pnpm test -- import-alert --reporter=verbose || {
            echo "Import-alert service tests failed, showing test output..."
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return
          JWT_ACCESS_SECRET: test-access-secret-1234567890
          JWT_REFRESH_SECRET: test-refresh-secret-1234567890
          CAMERA_TYPE: mock
          PHOTO_STORAGE_DIR: /tmp/test-photo-storage
          BACKUP_STORAGE_DIR: /tmp/test-backups
          NODE_ENV: test

      - name: Start API server for monitoring tests
        run: |
          cd apps/api
          # バックグラウンドでAPIサーバーを起動
          # NODE_ENVをproductionに設定してAPIサーバーを起動（testだとmain.tsで起動しない）
          NODE_ENV=production pnpm start > /tmp/api-server.log 2>&1 &
          API_PID=$!
          echo "API_PID=$API_PID" >> $GITHUB_ENV
          echo "API server started with PID: $API_PID"
          
          # 少し待ってからログを確認
          sleep 2
          echo "API server log (first 50 lines):"
          head -50 /tmp/api-server.log || echo "No log file yet"
          
          # APIサーバーが起動するまで待機
          timeout=30
          elapsed=0
          until curl -s http://localhost:8080/api/system/health > /dev/null 2>&1; do
            if [ $elapsed -ge $timeout ]; then
              echo "API server failed to start within $timeout seconds"
              echo "API server log (full):"
              cat /tmp/api-server.log || true
              echo "Checking if process is still running:"
              ps aux | grep -E "node|pnpm" | grep -v grep || true
              echo "Checking port 8080:"
              netstat -tuln | grep 8080 || ss -tuln | grep 8080 || true
              exit 1
            fi
            echo "Waiting for API server... ($elapsed/$timeout seconds)"
            sleep 1
            elapsed=$((elapsed + 1))
          done
          echo "API server is ready!"
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return
          # NOTE:
          # NODE_ENV=production でAPIを起動するため、Fail-fastシークレットポリシーを満たす強い値を使用する。
          JWT_ACCESS_SECRET: ci-prod-access-secret-0123456789-abcdefghijklmnopqrstuvwxyz
          JWT_REFRESH_SECRET: ci-prod-refresh-secret-0123456789-abcdefghijklmnopqrstuvwxyz
          PORT: 8080
          HOST: 0.0.0.0

      - name: Test backup/restore scripts
        run: |
          echo "Testing backup/restore scripts..."
          # CI環境ではpostgres-testコンテナを使用
          export COMPOSE_FILE="infrastructure/docker/docker-compose.server.yml"
          # postgres-testコンテナが起動していることを確認
          docker ps | grep postgres-test || {
            echo "PostgreSQL test container is not running"
            exit 1
          }
          # バックアップテストを実行（postgres-testコンテナを直接使用）
          bash scripts/test/backup-restore.test.sh || {
            echo "Backup/restore tests failed!"
            exit 1
          }

      - name: Install Ansible for template rendering
        run: |
          python3 -m pip install --user ansible-core || {
            echo "Warning: Failed to install ansible-core, tests will use sed fallback"
          }

      - name: Ansible syntax check
        run: |
          echo "Running Ansible syntax check..."
          cd infrastructure/ansible
          export PATH="$HOME/.local/bin:$PATH"
          
          # Check if ansible-playbook is available
          if ! command -v ansible-playbook &> /dev/null; then
            echo "ansible-playbook not found, skipping Ansible tests"
            exit 0
          fi
          
          # Install required Ansible collections
          echo "Installing Ansible collections..."
          ansible-galaxy collection install community.general || {
            echo "Warning: Failed to install community.general collection, but continuing..."
          }
          
          # Create temporary ansible.cfg without vault_password_file for syntax check
          # (vault decryption not needed for syntax validation)
          cp ansible.cfg /tmp/ansible.cfg.backup || true
          sed 's/^vault_password_file = .vault-pass/# vault_password_file = .vault-pass (disabled for CI syntax check)/' ansible.cfg > /tmp/ansible-ci.cfg
          export ANSIBLE_CONFIG=/tmp/ansible-ci.cfg
          export ANSIBLE_ROLES_PATH="$(pwd)/roles"
          
          # Test all playbooks
          # Note: backup-clients.yml and backup-client-directory.yml require runtime variables
          # (client_host, client_file_path, etc.) and are excluded from syntax check
          PLAYBOOKS=(
            "playbooks/deploy.yml"
            "playbooks/update-clients.yml"
            "playbooks/health-check.yml"
            "playbooks/manage-system-configs.yml"
            "playbooks/manage-app-configs.yml"
            "playbooks/rollback.yml"
            "playbooks/restart-services.yml"
            "playbooks/ping.yml"
          )
          
          FAILED=0
          for playbook in "${PLAYBOOKS[@]}"; do
            echo "Checking syntax for $playbook..."
            # Use inventory.yml for syntax check (doesn't need real hosts)
            # Note: Vault files will fail to decrypt, but syntax check will still validate YAML structure
            if ansible-playbook --syntax-check "$playbook" -i inventory.yml > /tmp/ansible-syntax-check.log 2>&1; then
              echo "✅ $playbook syntax OK"
            else
              # Check if error is due to vault decryption (expected) or actual syntax error
              if grep -qE "(vault password|ERROR.*vault)" /tmp/ansible-syntax-check.log && ! grep -qE "(syntax error|YAML|parse error)" /tmp/ansible-syntax-check.log; then
                echo "⚠️  $playbook syntax check skipped (vault file decryption failed, but YAML syntax is OK)"
              else
                echo "❌ $playbook syntax check failed:"
                cat /tmp/ansible-syntax-check.log
                FAILED=1
              fi
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            echo "Ansible syntax check failed!"
            exit 1
          fi
          
          echo "All Ansible playbooks passed syntax check!"

      - name: Ansible dry-run check (deploy playbook only)
        run: |
          echo "Running Ansible dry-run check for deploy.yml..."
          cd infrastructure/ansible
          export PATH="$HOME/.local/bin:$PATH"
          
          # Check if ansible-playbook is available
          if ! command -v ansible-playbook &> /dev/null; then
            echo "ansible-playbook not found, skipping Ansible dry-run"
            exit 0
          fi
          
          # Install required Ansible collections (if not already installed)
          echo "Installing Ansible collections..."
          ansible-galaxy collection install community.general || {
            echo "Warning: Failed to install community.general collection, but continuing..."
          }
          
          # Create temporary ansible.cfg without vault_password_file for dry-run check
          # (vault decryption not needed for dry-run validation)
          cp ansible.cfg /tmp/ansible.cfg.backup || true
          sed 's/^vault_password_file = .vault-pass/# vault_password_file = .vault-pass (disabled for CI dry-run check)/' ansible.cfg > /tmp/ansible-ci.cfg
          export ANSIBLE_CONFIG=/tmp/ansible-ci.cfg
          export ANSIBLE_ROLES_PATH="$(pwd)/roles"
          
          # Dry-run check for deploy.yml (most critical playbook)
          # Note: This will skip tasks that require actual host connection, but will validate
          # variable references, task structure, and role dependencies
          echo "Running dry-run check for playbooks/deploy.yml..."
          ansible-playbook --check --diff playbooks/deploy.yml -i inventory.yml --limit nonexistent_host 2>&1 | tee /tmp/ansible-dryrun.log || true
          
          # Check if error is due to no hosts (expected) or actual syntax/logic error
          if grep -qE "(No hosts matched|leaves us with no hosts to target)" /tmp/ansible-dryrun.log; then
            echo "✅ deploy.yml dry-run check completed (no hosts matched, which is expected for syntax validation)"
          elif grep -qE "(ERROR|error)" /tmp/ansible-dryrun.log && ! grep -qE "(No hosts matched|leaves us with no hosts|vault password)" /tmp/ansible-dryrun.log; then
            echo "❌ deploy.yml dry-run check failed with actual errors:"
            cat /tmp/ansible-dryrun.log
            exit 1
          else
            echo "✅ deploy.yml dry-run check completed"
          fi

      - name: Test monitoring scripts
        run: |
          echo "Testing monitoring scripts..."
          API_URL=http://localhost:8080/api pnpm test:monitor || {
            echo "Monitoring tests failed!"
            echo "API server log:"
            cat /tmp/api-server.log || true
            exit 1
          }

      - name: Security scan (Trivy fs)
        uses: aquasecurity/trivy-action@0.25.0
        with:
          scan-type: 'fs'
          ignore-unfixed: true
          severity: 'HIGH,CRITICAL'
          exit-code: '1'
          scanners: 'vuln'
          skip-dirs: |
            **/certs
            **/alerts

      - name: Build api image for Trivy image scan
        run: docker build -t raspisys-api:ci -f infrastructure/docker/Dockerfile.api .

      - name: Build web image for Trivy image scan
        run: docker build -t raspisys-web:ci -f infrastructure/docker/Dockerfile.web .

      - name: Security scan (Trivy image api)
        uses: aquasecurity/trivy-action@0.25.0
        with:
          scan-type: 'image'
          image-ref: 'raspisys-api:ci'
          ignore-unfixed: true
          severity: 'HIGH,CRITICAL'
          exit-code: '1'
          scanners: 'vuln'

      - name: Security scan (Trivy image web)
        uses: aquasecurity/trivy-action@0.25.0
        with:
          scan-type: 'image'
          image-ref: 'raspisys-web:ci'
          ignore-unfixed: true
          severity: 'HIGH,CRITICAL'
          exit-code: '1'
          scanners: 'vuln'
          trivyignores: '.trivyignore'

      - name: Stop API server
        if: always()
        run: |
          if [ -n "$API_PID" ]; then
            echo "Stopping API server (PID: $API_PID)"
            kill $API_PID || true
            sleep 2
            kill -9 $API_PID 2>/dev/null || true
          fi
          pkill -f "node dist/main.js" || true
          pkill -f "pnpm start" || true

      - name: Cleanup PostgreSQL
        if: always()
        run: docker stop postgres-test && docker rm postgres-test || true

      - name: Build Web
        run: |
          cd apps/web
          pnpm build || {
            echo "Build Web failed!"
            exit 1
          }

  e2e-smoke:
    runs-on: ubuntu-latest
    needs: lint-and-test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install Playwright browsers
        run: pnpm exec playwright install --with-deps chromium

      - name: Start PostgreSQL (smoke)
        run: |
          docker run -d \
            --name postgres-e2e-smoke \
            -e POSTGRES_PASSWORD=postgres \
            -e POSTGRES_DB=borrow_return \
            -p 5432:5432 \
            --health-cmd="pg_isready -U postgres" \
            --health-interval=10s \
            --health-timeout=5s \
            --health-retries=5 \
            postgres:15-alpine

      - name: Wait for PostgreSQL (smoke)
        run: |
          timeout=60
          elapsed=0
          until docker exec postgres-e2e-smoke pg_isready -U postgres 2>/dev/null; do
            if [ $elapsed -ge $timeout ]; then
              echo "PostgreSQL failed to start within $timeout seconds"
              docker logs postgres-e2e-smoke
              exit 1
            fi
            echo "Waiting for PostgreSQL... ($elapsed/$timeout seconds)"
            sleep 2
            elapsed=$((elapsed + 2))
          done
          echo "PostgreSQL is ready!"

      - name: Generate Prisma Client (smoke)
        run: |
          cd apps/api
          pnpm prisma generate || {
            echo "Prisma generate failed!"
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return

      - name: Run Prisma migrations (smoke)
        run: |
          cd apps/api
          pnpm prisma migrate deploy || {
            echo "Prisma migrate deploy failed!"
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return

      - name: Seed database (smoke)
        run: |
          cd apps/api
          pnpm prisma db seed || {
            echo "Database seed failed!"
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return

      - name: Run E2E smoke tests
        env:
          CI: true
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return
          VITE_KIOSK_DEFAULT_MODE: TAG
        run: |
          pnpm test:e2e:smoke || {
            echo "E2E smoke tests failed!"
            exit 1
          }

      - name: Cleanup PostgreSQL (smoke)
        if: always()
        run: docker stop postgres-e2e-smoke && docker rm postgres-e2e-smoke

  e2e-tests:
    runs-on: ubuntu-latest
    needs: e2e-smoke
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install Playwright browsers
        run: pnpm exec playwright install --with-deps chromium

      - name: Build shared-types
        run: |
          cd packages/shared-types
          pnpm build || {
            echo "Build shared-types failed!"
            exit 1
          }

      - name: Generate Prisma Client
        run: |
          cd apps/api
          pnpm prisma generate || {
            echo "Prisma generate failed!"
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return

      - name: Build API
        run: |
          cd apps/api
          pnpm build || {
            echo "Build API failed!"
            exit 1
          }

      - name: Build Web
        run: |
          cd apps/web
          pnpm build || {
            echo "Build Web failed!"
            exit 1
          }

      - name: Start PostgreSQL
        run: |
          docker run -d \
            --name postgres-e2e \
            -e POSTGRES_PASSWORD=postgres \
            -e POSTGRES_DB=borrow_return \
            -p 5432:5432 \
            --health-cmd="pg_isready -U postgres" \
            --health-interval=10s \
            --health-timeout=5s \
            --health-retries=5 \
            postgres:15-alpine

      - name: Wait for PostgreSQL
        run: |
          timeout=60
          elapsed=0
          until docker exec postgres-e2e pg_isready -U postgres 2>/dev/null; do
            if [ $elapsed -ge $timeout ]; then
              echo "PostgreSQL failed to start within $timeout seconds"
              docker logs postgres-e2e
              exit 1
            fi
            echo "Waiting for PostgreSQL... ($elapsed/$timeout seconds)"
            sleep 2
            elapsed=$((elapsed + 2))
          done
          echo "PostgreSQL is ready!"

      - name: Run Prisma migrations
        run: |
          cd apps/api
          pnpm prisma migrate deploy || {
            echo "Prisma migrate deploy failed!"
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return

      - name: Seed database
        run: |
          cd apps/api
          pnpm prisma db seed || {
            echo "Database seed failed!"
            exit 1
          }
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return

      - name: Run E2E tests
        run: |
          echo "Running E2E tests..."
          pnpm test:e2e || {
            echo "E2E tests failed!"
            exit 1
          }
        env:
          CI: true
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/borrow_return
          JWT_ACCESS_SECRET: test-access-secret-1234567890
          JWT_REFRESH_SECRET: test-refresh-secret-1234567890
          BACKUP_CONFIG_PATH: /tmp/e2e-backup.json
          BACKUP_STORAGE_DIR: /tmp/e2e-backups

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30

      - name: Cleanup
        if: always()
        run: |
          docker stop postgres-e2e || true
          docker rm postgres-e2e || true

  docker-build:
    runs-on: ubuntu-latest
    needs: [lint-and-test, e2e-smoke]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build API Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./infrastructure/docker/Dockerfile.api
          push: false
          tags: raspberry-pi-system-api:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build Web Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./infrastructure/docker/Dockerfile.web
          push: false
          tags: raspberry-pi-system-web:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

